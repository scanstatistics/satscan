<html><head><title> zziplib autodoc documentation </title></head>
<body>

<h1>zziplib <small><small><i>-0.10.27
</i></small></small></h1>
<table border=0 cellspacing=0 cellpadding=0><tr><td><code>
uint32_t </code></td><td><a href="#__zzip_get32"><code>__zzip_get32</code></a></td><td><code>(unsigned char * s)
</code></td></tr><tr><td><code>
uint16_t </code></td><td><a href="#__zzip_get16"><code>__zzip_get16</code></a></td><td><code>(unsigned char * s)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_find_disk_trailer"><code>zzip_find_disk_trailer</code></a></td><td><code>(int fd, int filesize, struct zzip_disk_trailer * trailer)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_parse_root_directory"><code>zzip_parse_root_directory</code></a></td><td><code>(int fd, 
    struct zzip_disk_trailer * trailer, 
    struct zzip_dir_hdr ** hdr_return)
</code></td></tr><tr><td><code>
ZZIP_DIR*
</code></td><td><a href="#zzip_dir_alloc"><code>zzip_dir_alloc</code></a></td><td><code> (const char** fileext)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_dir_free"><code>zzip_dir_free</code></a></td><td><code>(ZZIP_DIR * dir)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_dir_close"><code>zzip_dir_close</code></a></td><td><code>(ZZIP_DIR * dir)
</code></td></tr><tr><td><code>
ZZIP_DIR * 
</code></td><td><a href="#zzip_dir_fdopen"><code>zzip_dir_fdopen</code></a></td><td><code>(int fd, zzip_error_t * errcode_p)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#__zzip_open_zip"><code>__zzip_open_zip</code></a></td><td><code>(const char* filename, int filemode)
</code></td></tr><tr><td><code>
ZZIP_DIR* 
</code></td><td><a href="#zzip_dir_open"><code>zzip_dir_open</code></a></td><td><code>(const char* filename, zzip_error_t* e)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_dir_read"><code>zzip_dir_read</code></a></td><td><code>(ZZIP_DIR * dir, ZZIP_DIRENT * d )
</code></td></tr><tr><td><code>
void 
</code></td><td><a href="#zzip_file_close"><code>zzip_file_close</code></a></td><td><code>(ZZIP_FILE * fp)
</code></td></tr><tr><td><code>
ZZIP_FILE * 
</code></td><td><a href="#zzip_file_open"><code>zzip_file_open</code></a></td><td><code>(ZZIP_DIR * dir, const char * name, int flags)
</code></td></tr><tr><td><code>
static int 
</code></td><td><a href="#zzip_inflate_init"><code>zzip_inflate_init</code></a></td><td><code>(ZZIP_FILE * fp, struct zzip_dir_hdr* hdr)
</code></td></tr><tr><td><code>
void 
</code></td><td><a href="#zzip_close"><code>zzip_close</code></a></td><td><code>(ZZIP_FILE * fp)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_file_read"><code>zzip_file_read</code></a></td><td><code>(ZZIP_FILE * fp, char * buf, int len)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_read"><code>zzip_read</code></a></td><td><code>(ZZIP_FILE * fp, char * buf, int len)
</code></td></tr><tr><td><code>
ZZIP_FILE*
</code></td><td><a href="#zzip_open"><code>zzip_open</code></a></td><td><code>(const char* filename, int flags)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_rewind"><code>zzip_rewind</code></a></td><td><code>(ZZIP_FILE *fp)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_seek"><code>zzip_seek</code></a></td><td><code>(ZZIP_FILE * fp, int offset, int whence)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_tell"><code>zzip_tell</code></a></td><td><code>(ZZIP_FILE * fp)
</code></td></tr><tr><td><code>
void 
</code></td><td><a href="#zzip_rewinddir"><code>zzip_rewinddir</code></a></td><td><code>(ZZIP_DIR * dir)
</code></td></tr><tr><td><code>
ZZIP_DIRENT* 
</code></td><td><a href="#zzip_readdir"><code>zzip_readdir</code></a></td><td><code>(ZZIP_DIR * dir)
</code></td></tr><tr><td><code>
ZZIP_off_t 
</code></td><td><a href="#zzip_telldir"><code>zzip_telldir</code></a></td><td><code>(ZZIP_DIR* dir)
</code></td></tr><tr><td><code>
void
</code></td><td><a href="#zzip_seekdir"><code>zzip_seekdir</code></a></td><td><code>(ZZIP_DIR* dir, ZZIP_off_t offset)
</code></td></tr><tr><td><code>
ZZIP_DIR* 
</code></td><td><a href="#zzip_opendir"><code>zzip_opendir</code></a></td><td><code>(const char* filename)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_closedir"><code>zzip_closedir</code></a></td><td><code>(ZZIP_DIR* dir)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_dir_stat"><code>zzip_dir_stat</code></a></td><td><code>(ZZIP_DIR * dir, const char * name, ZZIP_STAT * zs, int flags)
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_error"><code>zzip_error</code></a></td><td><code>(ZZIP_DIR * dir)   
</code></td></tr><tr><td><code>
void 
</code></td><td><a href="#zzip_seterror"><code>zzip_seterror</code></a></td><td><code>(ZZIP_DIR * dir, int errcode)   
</code></td></tr><tr><td><code>
ZZIP_DIR * 
</code></td><td><a href="#zzip_dirhandle"><code>zzip_dirhandle</code></a></td><td><code>(ZZIP_FILE * fp)   
</code></td></tr><tr><td><code>
int 
</code></td><td><a href="#zzip_dirfd"><code>zzip_dirfd</code></a></td><td><code>(ZZIP_DIR* dir)   
</code></td></tr><tr><td><code>
const char*
</code></td><td><a href="#zzip_compr_str"><code>zzip_compr_str</code></a></td><td><code>(int compr)
</code></td></tr><tr><td><code> 
int
</code></td><td><a href="#zzip_dir_real"><code>zzip_dir_real</code></a></td><td><code>(ZZIP_DIR* dir)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_file_real"><code>zzip_file_real</code></a></td><td><code>(ZZIP_FILE* fp)
</code></td></tr><tr><td><code>
void*
</code></td><td><a href="#zzip_realdir"><code>zzip_realdir</code></a></td><td><code>(ZZIP_DIR* dir)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_realfd"><code>zzip_realfd</code></a></td><td><code>(ZZIP_FILE* fp)
</code></td></tr><tr><td><code>
const char* 
</code></td><td><a href="#zzip_strerror"><code>zzip_strerror</code></a></td><td><code>(int errcode)
</code></td></tr><tr><td><code>
const char* 
</code></td><td><a href="#zzip_strerror_of"><code>zzip_strerror_of</code></a></td><td><code>(ZZIP_DIR* dir)
</code></td></tr><tr><td><code>
int
</code></td><td><a href="#zzip_errno"><code>zzip_errno</code></a></td><td><code>(int errcode)
</code></td></tr>
</table>
<h3>Documentation</h3>

<dl>
<dt><a name="__zzip_get32" /><code><code>
uint32_t </code><br /><b><code>__zzip_get32</code></b>&nbsp; <code>(unsigned char * s)
</code></code><dt>
<dd> <br />  Make 32 bit value in host byteorder from little-endian mapped octet-data 
 <br />  (works also on machines which SIGBUS on misaligned data access (eg. 68000)) 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="__zzip_get16" /><code><code>
uint16_t </code><br /><b><code>__zzip_get16</code></b>&nbsp; <code>(unsigned char * s)
</code></code><dt>
<dd> <br />  Make 16 bit value in host byteorder from little-endian mapped octet-data 
 <br />  (works also on machines which SIGBUS on misaligned data access (eg. 68000)) 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_find_disk_trailer" /><code><code>
int 
</code><br /><b><code>zzip_find_disk_trailer</code></b>&nbsp; <code>(int fd, int filesize, struct zzip_disk_trailer * trailer)
</code></code><dt>
<dd> <br />  the function for use by  <a href="#zzip_file_open"><code>zzip_file_open</code></a>. Tries to find 
 <br />  the zip's central directory info that is usually a few 
 <br />  bytes off the end of the file. 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_parse_root_directory" /><code><code>
int 
</code><br /><b><code>zzip_parse_root_directory</code></b>&nbsp; <code>(int fd, 
    struct zzip_disk_trailer * trailer, 
    struct zzip_dir_hdr ** hdr_return)
</code></code><dt>
<dd> <br />  the function for use by  <a href="#zzip_file_open"><code>zzip_file_open</code></a>, it is usually called after 
 <br />   <a href="#zzip_find_disk_trailer"><code>zzip_find_disk_trailer</code></a>. It will parse the zip's central directory 
 <br />  information and create a zziplib private directory table in 
 <br />  memory. 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_dir_alloc" /><code><code>
ZZIP_DIR*
</code><br /><b><code>zzip_dir_alloc</code></b>&nbsp; <code> (const char** fileext)
</code></code><dt>
<dd> <br />  allocate a new ZZIP_DIR handle and do basic  
 <br />  initializations before usage by  <a href="#zzip_dir_fdopen"><code>zzip_dir_fdopen</code></a> 
 <br />   <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>  <a href="#zzip_file_open"><code>zzip_file_open</code></a> or through 
 <br />   <a href="#zzip_open"><code>zzip_open</code></a> 
 <br />  (fileext null flags uses { ".zip" , ".ZIP" } ) 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_dir_free" /><code><code>
int 
</code><br /><b><code>zzip_dir_free</code></b>&nbsp; <code>(ZZIP_DIR * dir)
</code></code><dt>
<dd> <br />  will free the zzip_dir handle unless there are still  
 <br />  zzip_files attached (that may use its cache buffer). 
 <br />  This is the inverse of  <a href="#zzip_dir_alloc"><code>zzip_dir_alloc</code></a> , and both 
 <br />  are helper functions used implicitly in other zzipcalls 
 <br />  e.g.  <a href="#zzip_dir_close"><code>zzip_dir_close</code></a> = zzip_close  
 <br />  
 <br />  returns zero on sucess 
 <br />  returns the refcount when files are attached. 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_dir_close" /><code><code>
int 
</code><br /><b><code>zzip_dir_close</code></b>&nbsp; <code>(ZZIP_DIR * dir)
</code></code><dt>
<dd> <br />  It will also  <code>free</code>(2) the  <code>ZZIP_DIR</code>-handle given.  
 <br />  the counterpart for  <a href="#zzip_dir_open"><code>zzip_dir_open</code></a> 
 <br />  see also  <a href="#zzip_dir_free"><code>zzip_dir_free</code></a> 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_dir_fdopen" /><code><code>
ZZIP_DIR * 
</code><br /><b><code>zzip_dir_fdopen</code></b>&nbsp; <code>(int fd, zzip_error_t * errcode_p)
</code></code><dt>
<dd> <br />  used by the  <a href="#zzip_dir_open"><code>zzip_dir_open</code></a> and zzip_opendir(2) call. Opens the 
 <br />  zip-archive as specified with the fd which points to an 
 <br />  already openend file. This function then search and parse 
 <br />  the zip's central directory. 
 <br />  <p>  
 <br />  NOTE: refcount is zero, so an _open/_close pair will also delete  
 <br />        this _dirhandle  
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="__zzip_open_zip" /><code><code>
int
</code><br /><b><code>__zzip_open_zip</code></b>&nbsp; <code>(const char* filename, int filemode)
</code></code><dt>
<dd> <br />  will attach a .zip extension and tries to open it 
 <br />  the with  <code>open</code>(2). This is a helper function for 
 <br />   <a href="#zzip_dir_open"><code>zzip_dir_open</code></a>,  <a href="#zzip_opendir"><code>zzip_opendir</code></a> and  <a href="#zzip_open"><code>zzip_open</code></a>. 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_dir_open" /><code><code>
ZZIP_DIR* 
</code><br /><b><code>zzip_dir_open</code></b>&nbsp; <code>(const char* filename, zzip_error_t* e)
</code></code><dt>
<dd> <br />  Opens the zip-archive (if available). 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_dir_read" /><code><code>
int
</code><br /><b><code>zzip_dir_read</code></b>&nbsp; <code>(ZZIP_DIR * dir, ZZIP_DIRENT * d )
</code></code><dt>
<dd> <br />  fills the dirent-argument with the values and  
 <br />  increments the read-pointer of the dir-argument. 
 <br />  <p> 
 <br />  returns 0 if there no entry (anymore). 
 
<p align="right"><small>(zzip-zip.c)</small></p></dd>
<dt><a name="zzip_file_close" /><code><code>
void 
</code><br /><b><code>zzip_file_close</code></b>&nbsp; <code>(ZZIP_FILE * fp)
</code></code><dt>
<dd> <br />  the direct function of  <a href="#zzip_close"><code>zzip_close</code></a>(fp). it will cleanup the 
 <br />  inflate-portion of  <code>zlib</code> and free the structure given. 
 <br />  <p> 
 <br />  it is called quite from the error-cleanup parts 
 <br />  of the various  <code>_open</code> functions.  
 <br />  <p> 
 <br />  the .refcount is decreased and if zero the fp<small>-&gt;</small>dir is closed just as well. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_file_open" /><code><code>
ZZIP_FILE * 
</code><br /><b><code>zzip_file_open</code></b>&nbsp; <code>(ZZIP_DIR * dir, const char * name, int flags)
</code></code><dt>
<dd> <br />  open an  <code>ZZIP_FILE</code> from an already open  <code>ZZIP_DIR</code> handle. Since 
 <br />  we have a chance to reuse a cached  <code>buf32k</code> and  <code>ZZIP_FILE</code> memchunk 
 <br />  this is the best choice to unpack multiple files. 
 <br />  <p> 
 <br />  Note: the zlib supports 2..15 bit windowsize, hence we provide a 32k 
 <br />        memchunk here... just to be safe. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_inflate_init" /><code><code>
static int 
</code><br /><b><code>zzip_inflate_init</code></b>&nbsp; <code>(ZZIP_FILE * fp, struct zzip_dir_hdr* hdr)
</code></code><dt>
<dd> <br />   call  <code>inflateInit</code> and setup fp's iterator variables,  
 <br />   used by lowlevel  <code>_open</code> functions. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_close" /><code><code>
void 
</code><br /><b><code>zzip_close</code></b>&nbsp; <code>(ZZIP_FILE * fp)
</code></code><dt>
<dd> <br />  close an ZZIP_FILE handle. If the ZZIP_FILE wraps a normal stat'fd then it 
 <br />  is just that int'fd that is being closed and the otherwise empty ZZIP_FILE 
 <br />  gets freed. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_file_read" /><code><code>
int 
</code><br /><b><code>zzip_file_read</code></b>&nbsp; <code>(ZZIP_FILE * fp, char * buf, int len)
</code></code><dt>
<dd> <br />  works like  <code>read</code>(2), it will fill the given buffer with bytes from 
 <br />  the opened file. It will return the number of bytes read, so if the  <code>EOF</code> 
 <br />  is encountered you will be prompted with the number of bytes actually read. 
 <br />  <p> 
 <br />  This is the routines that needs the  <code>buf32k</code> buffer, and it would have 
 <br />  need for much more polishing but it does already work quite well. 
 <br />  <p> 
 <br />  Note: the 32K buffer is rather big. The original inflate-algorithm 
 <br />        required just that but the latest zlib would work just fine with 
 <br />        a smaller buffer. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_read" /><code><code>
int 
</code><br /><b><code>zzip_read</code></b>&nbsp; <code>(ZZIP_FILE * fp, char * buf, int len)
</code></code><dt>
<dd> <br />  the replacement for  <code>read</code>(2), it will fill the given buffer with bytes from 
 <br />  the opened file. It will return the number of bytes read, so if the EOF 
 <br />  is encountered you will be prompted with the number of bytes actually read. 
 <br />  <p> 
 <br />  If the file-handle is wrapping a stat'able file then it will actually just 
 <br />  perform a normal  <code>read</code>(2)-call, otherwise  <a href="#zzip_file_read"><code>zzip_file_read</code></a> is called 
 <br />  to decompress the data stream and any error is mapped to  <code>errno</code>(3). 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_open" /><code><code>
ZZIP_FILE*
</code><br /><b><code>zzip_open</code></b>&nbsp; <code>(const char* filename, int flags)
</code></code><dt>
<dd> <br />  see  <code>open</code>(2). 
 <br />  <p> 
 <br />  This functions has some magic builtin - it will first try to open 
 <br />  the given <em>filename</em> as a normal file. If it does not 
 <br />  exist, the given path to the filename (if any) is split into 
 <br />  its directory-part and the file-part. A ".zip" extension is 
 <br />  then added to the directory-part to create the name of a 
 <br />  zip-archive. That zip-archive (if it exists) is being searched 
 <br />  for the file-part, and if found a zzip-handle is returned.  
 <br />  <p> 
 <br />  Note that if the file is found in the normal fs-directory the 
 <br />  returned structure is mostly empty and the  <a href="#zzip_read"><code>zzip_read</code></a> call will 
 <br />  use the libc  <code>read</code> to obtain data. Otherwise a  <a href="#zzip_file_open"><code>zzip_file_open</code></a>  
 <br />  is performed and any error mapped to  <code>errno</code>(3). 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_rewind" /><code><code>
int
</code><br /><b><code>zzip_rewind</code></b>&nbsp; <code>(ZZIP_FILE *fp)
</code></code><dt>
<dd> <br />  Rewind an ZZIP_FILE handle. Seeks to the beginning of this file's 
 <br />  data in the zip, or the beginning of the file for a stat'fd. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_seek" /><code><code>
int
</code><br /><b><code>zzip_seek</code></b>&nbsp; <code>(ZZIP_FILE * fp, int offset, int whence)
</code></code><dt>
<dd> <br />  the replacement for  <code>lseek</code>(2), it will seek to the offset 
 <br />  specified by offset, relative to whence, which is one of 
 <br />  SEEK_SET, SEEK_CUR or SEEK_END. 
 <br />  <p> 
 <br />  If the file-handle is wrapping a stat'able file then it will actually just 
 <br />  perform a normal  <code>lseek</code>(2)-call. Otherwise the relative offset 
 <br />  is calculated, negative offsets are transformed into positive ones 
 <br />  by rewinding the file, and then data is read until the offset is 
 <br />  reached.  This can make the function terribly slow, but this is 
 <br />  how gzio implements it, so I'm not sure there is a better way 
 <br />  without using the internals of the algorithm. 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_tell" /><code><code>
int
</code><br /><b><code>zzip_tell</code></b>&nbsp; <code>(ZZIP_FILE * fp)
</code></code><dt>
<dd> <br />  the replacement for  <code>tell</code>(2), it will return the current offset 
 <br />  in the file, in uncompressed bytes. 
 <br />  <p> 
 <br />  If the file-handle is wrapping a stat'able file then it will actually just 
 <br />  perform a normal  <code>tell</code>(2)-call, otherwise the offset is 
 <br />  calculated from the amount of data left and the total uncompressed 
 <br />  size; 
 
<p align="right"><small>(zzip-file.c)</small></p></dd>
<dt><a name="zzip_rewinddir" /><code><code>
void 
</code><br /><b><code>zzip_rewinddir</code></b>&nbsp; <code>(ZZIP_DIR * dir)
</code></code><dt>
<dd> <br />  see  <code>rewinddir</code>(2), rewinds the DIR returned by  <a href="#zzip_opendir"><code>zzip_opendir</code></a> 
 
<p align="right"><small>(zzip-dir.c)</small></p></dd>
<dt><a name="zzip_readdir" /><code><code>
ZZIP_DIRENT* 
</code><br /><b><code>zzip_readdir</code></b>&nbsp; <code>(ZZIP_DIR * dir)
</code></code><dt>
<dd> <br />  see  <code>readdir</code>(2), reads the DIR returned by  <a href="#zzip_opendir"><code>zzip_opendir</code></a> 
 
<p align="right"><small>(zzip-dir.c)</small></p></dd>
<dt><a name="zzip_telldir" /><code><code>
ZZIP_off_t 
</code><br /><b><code>zzip_telldir</code></b>&nbsp; <code>(ZZIP_DIR* dir)
</code></code><dt>
<dd> <br />  see  <code>telldir</code>(2) 
 
<p align="right"><small>(zzip-dir.c)</small></p></dd>
<dt><a name="zzip_seekdir" /><code><code>
void
</code><br /><b><code>zzip_seekdir</code></b>&nbsp; <code>(ZZIP_DIR* dir, ZZIP_off_t offset)
</code></code><dt>
<dd> <br />  see  <code>seekdir</code>(2) 
 
<p align="right"><small>(zzip-dir.c)</small></p></dd>
<dt><a name="zzip_opendir" /><code><code>
ZZIP_DIR* 
</code><br /><b><code>zzip_opendir</code></b>&nbsp; <code>(const char* filename)
</code></code><dt>
<dd> <br />  see  <code>opendir</code>(3).  
 <br />  <p> 
 <br />  This function has some magic - if the given argument-path 
 <br />  is a directory, it will wrap a real  <code>opendir</code>(3) into the ZZIP_DIR 
 <br />  structure. Otherwise it will divert to  <a href="#zzip_dir_open"><code>zzip_dir_open</code></a> which  
 <br />  can also attach a .zip extension if needed to find the archive. 
 <br />  <p> 
 <br />  the error-code is mapped to  <code>errno</code>(3). 
 
<p align="right"><small>(zzip-dir.c)</small></p></dd>
<dt><a name="zzip_closedir" /><code><code>
int
</code><br /><b><code>zzip_closedir</code></b>&nbsp; <code>(ZZIP_DIR* dir)
</code></code><dt>
<dd> <br />  see  <code>closedir</code>(3). 
 <br />  <p> 
 <br />  This function is magic - if the given arg-ZZIP_DIR 
 <br />  is a real directory, it will call the real  <code>closedir</code>(3) and then 
 <br />  free the wrapping ZZIP_DIR structure. Otherwise it will divert  
 <br />  to  <a href="#zzip_dir_close"><code>zzip_dir_close</code></a> which will free the ZZIP_DIR structure. 
 
<p align="right"><small>(zzip-dir.c)</small></p></dd>
<dt><a name="zzip_dir_stat" /><code><code>
int 
</code><br /><b><code>zzip_dir_stat</code></b>&nbsp; <code>(ZZIP_DIR * dir, const char * name, ZZIP_STAT * zs, int flags)
</code></code><dt>
<dd> <br />  obtain information about a filename in a zip-archive without  
 <br />  opening that file first. Mostly used to obtain the uncompressed  
 <br />  size of file inside a zip-archive. 
 
<p align="right"><small>(zzip-stat.c)</small></p></dd>
<dt><a name="zzip_error" /><code><code>
int 
</code><br /><b><code>zzip_error</code></b>&nbsp; <code>(ZZIP_DIR * dir)   
</code></code><dt>
<dd> <br />   return dir<small>-&gt;</small>errcode  
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_seterror" /><code><code>
void 
</code><br /><b><code>zzip_seterror</code></b>&nbsp; <code>(ZZIP_DIR * dir, int errcode)   
</code></code><dt>
<dd> <br />   dir<small>-&gt;</small>errcode = errcode  
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_dirhandle" /><code><code>
ZZIP_DIR * 
</code><br /><b><code>zzip_dirhandle</code></b>&nbsp; <code>(ZZIP_FILE * fp)   
</code></code><dt>
<dd> <br />  return fp<small>-&gt;</small>dir  
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_dirfd" /><code><code>
int 
</code><br /><b><code>zzip_dirfd</code></b>&nbsp; <code>(ZZIP_DIR* dir)   
</code></code><dt>
<dd> <br />   return dir<small>-&gt;</small>fd  
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_compr_str" /><code><code>
const char*
</code><br /><b><code>zzip_compr_str</code></b>&nbsp; <code>(int compr)
</code></code><dt>
<dd> <br />  return static const string of the known compression methods,  
 <br />  otherwise "zipped" is returned 
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_dir_real" /><code><code> 
int
</code><br /><b><code>zzip_dir_real</code></b>&nbsp; <code>(ZZIP_DIR* dir)
</code></code><dt>
<dd> <br />  return if the DIR-handle is wrapping a real directory 
 <br />  or a zip-archive. Returns 1 for a stat'able directory, 
 <br />  and 0 for a handle to zip-archive. 
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_file_real" /><code><code>
int
</code><br /><b><code>zzip_file_real</code></b>&nbsp; <code>(ZZIP_FILE* fp)
</code></code><dt>
<dd> <br />  return if the FILE-handle is wrapping a real file 
 <br />  or a zip-contained file. Returns 1 for a stat'able file, 
 <br />  and 0 for a file inside a zip-archive. 
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_realdir" /><code><code>
void*
</code><br /><b><code>zzip_realdir</code></b>&nbsp; <code>(ZZIP_DIR* dir)
</code></code><dt>
<dd> <br />  return the posix DIR* handle (if one exists). 
 <br />  Check before with  <a href="#zzip_dir_real"><code>zzip_dir_real</code></a> if the 
 <br />  the ZZIP_DIR points to a real directory. 
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_realfd" /><code><code>
int
</code><br /><b><code>zzip_realfd</code></b>&nbsp; <code>(ZZIP_FILE* fp)
</code></code><dt>
<dd> <br />  return the posix file descriptor (if one exists). 
 <br />  Check before with  <a href="#zzip_file_real"><code>zzip_file_real</code></a> if the 
 <br />  the ZZIP_FILE points to a real file. 
 
<p align="right"><small>(zzip-info.c)</small></p></dd>
<dt><a name="zzip_strerror" /><code><code>
const char* 
</code><br /><b><code>zzip_strerror</code></b>&nbsp; <code>(int errcode)
</code></code><dt>
<dd> <br />  returns the static string for the given error code. The 
 <br />  error code can be either a normal system error (a 
 <br />  positive error code will flag this), it can be  <code>libz</code> 
 <br />  error code (a small negative error code will flag this) 
 <br />  or it can be an error code from  <code>libzzip</code>, which is an 
 <br />  negative value lower than  <code>ZZIP_ERROR</code> 
 
<p align="right"><small>(zzip-err.c)</small></p></dd>
<dt><a name="zzip_strerror_of" /><code><code>
const char* 
</code><br /><b><code>zzip_strerror_of</code></b>&nbsp; <code>(ZZIP_DIR* dir)
</code></code><dt>
<dd> <br />  read the errorcode from the  <code>DIR</code>-handle and run it 
 <br />  through  <a href="#zzip_strerror"><code>zzip_strerror</code></a> to obtain the static string 
 <br />  describing the error. 
 
<p align="right"><small>(zzip-err.c)</small></p></dd>
<dt><a name="zzip_errno" /><code><code>
int
</code><br /><b><code>zzip_errno</code></b>&nbsp; <code>(int errcode)
</code></code><dt>
<dd> <br />  map the error code to a system error code. This is used 
 <br />  for the drop-in replacement functions to return a value 
 <br />  that can be interpreted correctly by code sections that 
 <br />  are unaware of the fact they their  <code>open</code>(2) call had been 
 <br />  diverted to a file inside a zip-archive. 
 
<p align="right"><small>(zzip-err.c)</small></p></dd>
</dl>
</body></html>
